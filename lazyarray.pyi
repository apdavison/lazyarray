from numpy import (
    bool_,
    float64,
    int64,
    ndarray,
    ufunc,
)
from typing import (
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Tuple,
    Type,
    Union,
)


def _build_ufunc(func: ufunc) -> Callable: ...


def _build_ufunc_2nd_arg(func: ufunc) -> Callable: ...


def check_shape(meth: Callable) -> Callable: ...


def full_address(addr: Any, full_shape: Union[Tuple[int, int, int], Tuple[int], Tuple[int, int]]) -> Any: ...


def is_array_like(value: Any) -> bool: ...


def lazy_inplace_operation(name: str) -> Callable: ...


def lazy_operation(name: str, reversed: bool = ...) -> Callable: ...


def lazy_unary_operation(name: str) -> Callable: ...


def partial_shape(addr: Any, full_shape: Union[Tuple[int, int, int], Tuple[int, int], Tuple[int]]) -> Any: ...


def requires_shape(meth: Callable) -> Callable: ...


def reverse(func: Callable) -> Callable: ...


class larray:
    def __call__(self, arg: larray) -> larray: ...
    def __deepcopy__(self, memo: Dict[Any, Any]) -> larray: ...
    def __eq__(self, other: Union[larray, ndarray, float, int]) -> Union[bool_, bool]: ...
    def __getitem__(self, addr: Any) -> Union[ndarray, int64, float64, float, int]: ...
    def __init__(
        self,
        value: Any,
        shape: Optional[Union[Tuple[int, int, int], Tuple[int], int, Tuple[int, int]]] = ...,
        dtype: Optional[Union[Type[int], Type[float]]] = ...
    ) -> None: ...
    def _apply_operations(
        self,
        x: Union[ndarray, int64, float64, float, int],
        addr: Optional[Any] = ...,
        simplify: bool = ...
    ) -> Any: ...
    def _array_indices(
        self,
        addr: Any
    ) -> Union[Tuple[ndarray], Tuple[ndarray, ndarray], List[int], List[ndarray]]: ...
    def _full_address(self, addr: Any) -> Any: ...
    def _homogeneous_array(self, addr: Any) -> ndarray: ...
    def _partial_shape(self, addr: Any) -> Any: ...
    def _partially_evaluate(
        self,
        addr: Any,
        simplify: bool = ...
    ) -> Union[ndarray, int64, float64, float, int]: ...
    def _set_shape(self, value: Union[Tuple[int], Tuple[int, int]]) -> None: ...
    def apply(self, f: Union[Callable, ufunc]) -> None: ...
    def check_bounds(self, addr: Any) -> None: ...
    def evaluate(self, simplify: bool = ..., empty_val: int = ...) -> Union[int, ndarray, float, bool]: ...
    @property
    def is_homogeneous(self) -> bool: ...
    @property
    def ncols(self) -> int: ...
    @property
    def nrows(self) -> int: ...
    @property
    def size(self) -> int: ...
